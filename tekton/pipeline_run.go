/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tekton

import (
	"fmt"
	libhandler "github.com/operator-framework/operator-lib/handler"
	"github.com/redhat-appstudio/internal-services/api/v1alpha1"
	"github.com/redhat-appstudio/internal-services/metadata"
	tektonv1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"reflect"
	"strings"
)

const (
	// internalRequestLabelPrefix is the prefix of the internal request labels
	internalRequestLabelPrefix = "internal-services.appstudio.openshift.io"

	// PipelineTypeRelease is the type for PipelineRuns created to run a release Pipeline
	PipelineTypeRelease = "release"
)

var (
	// InternalRequestNameLabel is the label used to specify the name of the internal request associated with the PipelineRun
	InternalRequestNameLabel = fmt.Sprintf("%s/%s", internalRequestLabelPrefix, "name")

	// InternalRequestNamespaceLabel is the label used to specify the namespace of the internal request associated with the PipelineRun
	InternalRequestNamespaceLabel = fmt.Sprintf("%s/%s", internalRequestLabelPrefix, "namespace")
)

// InternalRequestPipelineRun is a PipelineRun alias, so we can add new methods to it in this file.
type InternalRequestPipelineRun struct {
	tektonv1beta1.PipelineRun
}

// NewInternalRequestPipelineRun creates a PipelineRun for the given InternalRequest. The name will be autogenerated,
// using the name of the request as the prefix. The Pipeline information and namespace for the PipelineRun will be
// extracted from the given InternalServicesConfig.
func NewInternalRequestPipelineRun(internalServicesConfig *v1alpha1.InternalServicesConfig) *InternalRequestPipelineRun {
	pipelineRun := tektonv1beta1.PipelineRun{
		ObjectMeta: v1.ObjectMeta{
			GenerateName: strings.ToLower(reflect.TypeOf(v1alpha1.InternalRequest{}).Name()) + "-",
			Namespace:    internalServicesConfig.Namespace,
		},
	}

	return &InternalRequestPipelineRun{pipelineRun}
}

// AsPipelineRun casts the InternalRequestPipelineRun to PipelineRun, so it can be used in the Kubernetes client.
func (i *InternalRequestPipelineRun) AsPipelineRun() *tektonv1beta1.PipelineRun {
	return &i.PipelineRun
}

// WithInternalRequest appends the InternalRequest parameters to the PipelineRun passed as an argument and set labels
// referencing the InternalRequest.
func (i *InternalRequestPipelineRun) WithInternalRequest(internalRequest *v1alpha1.InternalRequest) *InternalRequestPipelineRun {
	for param, value := range internalRequest.Spec.Params {
		i.Spec.Params = append(i.Spec.Params, tektonv1beta1.Param{
			Name: param,
			Value: tektonv1beta1.ArrayOrString{
				Type:      tektonv1beta1.ParamTypeString,
				StringVal: value,
			},
		})
	}

	i.ObjectMeta.Labels = map[string]string{
		InternalRequestNameLabel:      internalRequest.Name,
		InternalRequestNamespaceLabel: internalRequest.Namespace,
		metadata.PipelinesTypeLabel:   PipelineTypeRelease,
	}

	return i
}

// WithOwner set's owner annotations to the InternalRequest PipelineRun.
func (i *InternalRequestPipelineRun) WithOwner(internalRequest *v1alpha1.InternalRequest) *InternalRequestPipelineRun {
	_ = libhandler.SetOwnerAnnotations(internalRequest, i)

	return i
}

// WithPipeline sets a PipelineRef to point to the specified pipeline. It will also add a Workspace if the Pipeline
// requires one with a name matching the name of the VolumeClaim defined in the InternalServicesConfig.
func (i *InternalRequestPipelineRun) WithPipeline(pipeline *tektonv1beta1.Pipeline, internalServicesConfig *v1alpha1.InternalServicesConfig) *InternalRequestPipelineRun {
	i.Spec.PipelineRef = &tektonv1beta1.PipelineRef{
		Name: pipeline.Name,
	}

	for _, workspace := range pipeline.Spec.Workspaces {
		if workspace.Name == internalServicesConfig.Spec.VolumeClaim.Name {
			i.Spec.Workspaces = []tektonv1beta1.WorkspaceBinding{
				{
					Name: internalServicesConfig.Spec.VolumeClaim.Name,
					VolumeClaimTemplate: &corev1.PersistentVolumeClaim{
						Spec: corev1.PersistentVolumeClaimSpec{
							AccessModes: []corev1.PersistentVolumeAccessMode{corev1.ReadWriteOnce},
							Resources: corev1.ResourceRequirements{
								Requests: corev1.ResourceList{
									corev1.ResourceStorage: resource.MustParse(internalServicesConfig.Spec.VolumeClaim.Size),
								},
							},
						},
					},
				},
			}
			break
		}
	}

	return i
}
